# tips

* ``C``语言中全局**变量**作用范围为整个工程， 静态全局变量作用范围为本文件，静态局部变量在编译时赋初值的，即只赋值一次，在程序运行时它已有初值。以后每次调用函数时不再重新赋初值而只是保留上次函数调用结束时的值。而对局部变量（自动变量）赋初值，不是在编译时进行的，而是在函数调用时进行，每调用一次函数重新给一次初值，相当于执行一次赋值语句。虽然静态局部变量在函数调用结束后仍然存在，但其他函数不能引用它。

  ![img](https://coekjan.github.io/img/CP-Mem-Space.svg)

* ``Python``的**传值和传址**是根据传入参数的类型来选择的，传值的参数类型：数字，字符串，元组（不可变对象）。传址的参数类型：列表，字典（可变对象）。函数外面的引用也同样遵循这个规则，如果``a``为``list``类型，如何将其赋值给``b``（传值）呢？（**严格来说``Python``没传值传址，只有可变对象于不可变对象**）

  ```python
  import copy
  
  a=[1,2,3]
  b=a
  a.append(4)
  print a,b
  
  a=[1,2,3]
  b=copy.copy(a)
  a.append(4)
  print a,b
  ```

  输出为

  ```
  [1, 2, 3, 4] [1, 2, 3, 4]
  [1, 2, 3, 4] [1, 2, 3]
  ```

  那如果``a``的元素类型为``list``那么就要用``b.copy.deepcopy(a)``了，使用``copy``模块的``copy``功能的时候，它会根据当前拷贝的数据类型是可变类型还是不可变类型，有不同的处理方式。而``deepcopy``就是完全拷贝了，注意``Java``其实和``Python``类似，不过``Java``都是传值，但是效果是一样的，可以理解为像基本类型``int,long``等等变量名的值就是实际值，而引用类型或是一些类变量名仅仅是一个指针，于是就非常清楚了

* ``Java``有**局部变量，成员变量（实例变量）和类变量（静态变量）**其中实例变量与对象共存亡，调用方式为对象调用，类变量与类共存亡，可以对象调用也可以类名调用

* ``Java``每个类都有**构造方法**。如果没有显式地为类定义构造方法，``Java`` 编译器将会为该类提供一个默认构造方法。在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。即用于初始化对象

* ``Java``在类中再定义类就叫做**内部类**，

  1. 内部类提供更好的封装，把内部类隐藏在外部类之内，不允许同一个包中的其他类访问该类。

  2. 内部类成员可以直接访问外部类的私有数据，因为内部类被当成外部类的成员。然而外部类不能访问内部类的实现细节(如内部类的成员变量)。

  * **成员内部类**：成员内部类可以访问外部类的所有成员。外部类访问内部类，首先创建外部类对象去创建内部类对象，创建内部类对象的语法格式
  * **静态内部类**：内部类如果使用``static``关键字来声明，这个内部类叫做静态内部类。它是可以在不创建外部类对象被实例化。在静态内部类中只可以访问外部类的静态变量。如果访问外部类的成员变量必须通过外部类的实例去访问，静态内部不会有外部类的引用

- 个源文件中只能有一个`` public`` 类，一个源文件可以有多个非 ``public ``类，源文件的名称应该和 ``public`` 类的类名保持一致。例如：源文件中`` public ``类的类名是 ``Employee``，那么源文件应该命名为``Employee.java``。如果一个类定义在某个包中，那么 ``package`` 语句应该在源文件的首行。
- ``Java``：**内置数据类型：**该语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。``byte(8 bits),short(16 bits),int(32bits),long(64 bits),float(32 bits),double(64 bits),boolean(true or false),char(16 bits (Unicode))``，自动类型转换``byte,short,char—> int —> long—> float —> double ``

* ``Java``有很多修饰符：
  * **访问修饰符：default** (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。**private** : 在同一类内可见。使用对象：变量、方法。 **注意：不能修饰类（外部类）。public** : 对所有类可见。使用对象：类、接口、变量、方法。**protected** : 对同一包内的类和所有子类可见。使用对象：变量、方法。 **注意：不能修饰类（外部类）**。

* ``Java``向上转型是指引用对象为父类，创建对象为子类，向下转型就是将引用对象改回子类

  ```Java
  if(a instanceof B) {
      B b = (B) a;
  }
  ```

* ``Java``重写，即让子类重新实现一个在父类中已经实现的方法，实际调用**与引用对象无关**，**取决于引用对象的创建类型**，即同一个行为的不同表现类型又叫多态

* ``Java``的异常处理机制：异常的顶级父类是``Throwable``，它有两个子类：``Error``、``Exception``。

  ``Exception``：表示在合理的应用程序中出现的可以解决的问题，异常分类：

  * 编译时出现的异常，在编译时就出现并要求处理。比如：``CloneNotException``、``ParseException``
  * 运行时异常。在使用时侯可以处理，如果不处理就会报错。比如：``RuntimeException``、``NullPointerException``、``ArraryIndexOutOfBoundsException``、``ClassCastException``、``NoSuchElementException``

  异常有两种处理方式：``throws``、``try-catch``，还可以自己定义一个异常

  不需要捕获的异常包括``Error``及其子类，``RuntimeException``（看具体问题）及其子类

  ```java
  try {
      return s.getBytes("GBK")
      //可能发生异常的代码
  } catch (/*要捕获异常*/ UnsupportedEncodingException e) {
      e.printStackTrace();
      //异常处理
  }catch() {
      
  } ...
      finally{
          //无论有无异常都会执行，也可以不写catch只写finally
      }
      //从上到下匹配，异常子类在前不然永远匹配不到，捕获到到异常后从上到下匹配catch()然后执行并退出
  ```

  如：

  ```java
  public byte[] getBytes(String charsetName) throws UnsupportedEncodingException {
      ...
  }
  ```

  使用``throws xxx``表示该方法可能会抛出的异常类型，调用方在调用的时候必须捕获这些异常，否则编译器会报错，当然也可以不捕获它：

  ```java
  static byte[] toGBK(String s) throws UnsupportedEncodingException {
          return s.getBytes("GBK");
      }
  ```

  表示该方法可能会抛出异常，就可以让``toGBK()``方法通过编译器检查，但如果外部调用``toGBK()``一样会报错，也就是说加了``throws xxx``无论是否真的异常要么在调用层函数声明可能有异常，然后在更高层捕获，要么在调用层捕获（其实也可以在``main``中声明，一路声明），同时有的异常不存在继承关系，且处理代码有相同，可以用``|``合并

  既然有了捕获异常，那么如何抛出异常呢，可以创建某个``Exception``实例，用·``throw``语句抛出，如果一个方法捕获了某个异常后，又在`catch`子句中抛出新的异常，就相当于把抛出的异常类型“转换”了，为了能追踪到完整的异常栈，在构造异常的时候，把原始的`Exception`实例传进去，新的`Exception`就可以持有原始`Exception`信息。一般``JVM``会先执行``finally``再抛出异常，如果在执行`finally`语句时抛出异常，那么，`catch`语句的异常还能否继续抛出？明`finally`抛出异常后，原来在`catch`中准备抛出的异常就“消失”了，因为只能抛出一个异常。没有被抛出的异常称为“被屏蔽”的异常（Suppressed Exception）。

  在极少数的情况下，我们需要获知所有的异常。如何保存所有的异常信息？方法是先用`origin`变量保存原始异常，然后调用`Throwable.addSuppressed()`，把原始异常添加进来，最后在`finally`抛出：

  ```java
  public class Main {
      public static void main(String[] args) throws Exception {
          Exception origin = null;
          try {
              System.out.println(Integer.parseInt("abc"));
          } catch (Exception e) {
              origin = e;
              throw e;
          } finally {
              Exception e = new IllegalArgumentException();
              if (origin != null) {
                  e.addSuppressed(origin);
              }
              throw e;
          }
      }
  }
  ```

  绝大多数情况下，在`finally`中不要抛出异常。因此，我们通常不需要关心`Suppressed Exception`

  可以``Exception("xxxx")``再``e.getMessage()``，内容就是在构造方法中，即``xxx``

* 注意抽象类可以实现方法，接口不行，都不能实例化

* `HashSet` 和 `HashMap` 这两种容器会通过调用对象的 `hashCode` 方法和 `equals` 方法来将任意对象作为``key``来使用。**这个知识点非常重要，请同学们务必弄懂其原理**。

  ``Java``中许多内置的类，比如 `Integer` 和 `BigInteger` 等等都已经实现了`compareTo`、`hashCode`、`equals` 方法，所以你才可以直接把他们当作 `TreeMap` 和 `HashMap` 的``key``来使用。比如``HashMap``通过键的``HashCode``存储数据加快访问，它重写了``Object``的``hashCode``以及``equals``方法，因为使用``Object``自带的``hashCode``，无法保证两个对象``equals``的时候 ``hashCode`` 必须相等的条件，所以重写后最终``hashCode`` 和`` equals``的关系为两个对象 ``equals``的时候，``hashCode``必须相等，但``hashCode``相等，对象不一定``equals``。

  ``hashCode`` 顾名思义是一个“散列值码”

  散列值，并不能表现其唯一性，但是有离散性，其意义在于类似于进行``hashMap``等操作时，加快对象比较的速度，进而加快对象搜索的速度。

  在``Java``中，重写``equals()``方法之后，是否需要重写``hashCode()``方法，那要看分情况来说明。有些情况下，是建议；有些情况下，是必须重写。

  首先说建议的情况：比如你的对象想放到``Set``集合或者是想作为``Map``的``key``时，那么你必须重写``equals()``方法（**在``Object``类中``equals()``是判断两个对象的地址是否相等而不是内容**），这样才能保证唯一性。当然，在这种情况下，你不想重写``hashCode()``方法，也没有错。但是，对于良好的编程风格而言，你应该在重写``equals（）``方法的同时，也重写``hashCode()``方法。

  必须重写``hashCode()``的情况：
   如果你的对象想放进散列存储的集合中（比如：``HashSet,LinkedHashSet``）或者想作为散列``Map``（例如：``HashMap,LinkedHashMap``等等）的``Key``时，在重写``equals()``方法的同时，必须重写``hashCode()``方法。

  最后明白两点就行了：
   1.``hashCode()``方法存在的主要目的就是提高效率。
   2.在集合中判断两个对象相等的条件，其实无论是往集合中存数据，还是从集合中取数据，包括如果控制唯一性等，都是用这个条件判断的，条件如下：
   首先判断两个对象的``hashCode``是否相等，如果不相等，就认为这两个对象不相等，就完成了。如果相等，才会判断两个对象的``equals()``是否相等，如果不相等，就认为这两个对象不相等，如果相等，那就认为这两个对象相等。
   上面的条件对于任何集合都是如此，只要理解上面的条件，你就明白了，为什么在有些情况下建议重写``hashCode()``。有些情况下，是必须要重写的，只有一个目的，就是提高效率，你想想，如果你重写了``hashCode()``,只要不满足第一个条件，那就直接可以判断两个对象是不等的，也就不用花费时间再去比较``equals``了。

  最后总结一句话就是，``hashCode()``方法存在的主要目的就是提高效率，但是如果你想把对象放到散列存储结构的集合中时，是必须要重写的。

  对于原始的``equals()``，（如``int``，``float``等）和``String``类（因为该类已重写了``equals``和``hashcode``方法）对象时，默认比较的是值，在比较其它自定义对象时都是比较的引用地址，如图所示，``int``是基本类型，值就直接保存在变量中。而``String``是引用类型，变量中保存的只是实际对象的地址。一般称这种变量为"引用"，引用指向实际对象，实际对象中保存着内容。

* 关于排序的``Comparebale``接口，要重写``CompareTo``函数，有可能还要重写``equals()``或者``hasCode``，如果比较的是基本类型就不用重写，如果是引用类型或者别的就要重写

* 假设有

  1. `class A implements Interface`
  2. `class B extends A`
  3. `class C extends A implements Interface`.

  那么:

  - **B和C都可以向上转型为`Interface`**
  - B和C在不覆盖接口定义的方法时都会用父类的实现
  - 在反射方法`getInterfaces()`中, A和C类都会有`Interface`, **但是B不会有`Interface`**

* **``Java``正则表达式：**

  1. **字符匹配符与范围控制符：**

     | .      | 任意字符                             |
     | ------ | ------------------------------------ |
     | **\s** | **空白字符**                         |
     | **\S** | **非空白字符**                       |
     | **\w** | **单词字符，包括字母，数字，下划线** |
     | **\W** | **非单词字符**                       |
     | **[]** | **范围中的字符**                     |
     | **\d** | **数字**                             |
     | **\D** | **非数字**                           |

     注意：对于``[]``，``[abc]``表示匹配``abc``中任意一个，``[a-z]``表示匹配``a``到``z``任意一个，``[^abc]``表示除了``abc``之外的其它字符，``[abc[d]]``表示匹配``abcd``中任意一个，``[abc&[bce]]``表示匹配``bc``中任意一个

     **闲来无事扯些别的：**

     ``windows``下``enter``是``\r\n``，即一个回车符（``\r``）加一个换行符（``\n``），``linux``下是``\n``，``mac``是``\r``

     而在常用的编程语言中语言中``\r``表示将光标移动到当前行的行首，``\n``表示将光标移动到下一行的行首，例如在``windows``系统下面``c``语言读到``\r\n``其实会自动丢掉``\r``只保留``\n``，``mac``下会将``\r``换成``\n``。。。

     比如有些万恶的``OJ``平台将``windows``下生成的文件放到``linux``下面去评测，如果是用``scanf``读字符串就会得到正确的结果，因为它遇到空白字符``\r\n``就不读了，但是``gets``不是，它读完一行才停，即因为是``linux``系统，一行结束标志是一个换行符，``gets``遇到``\r\n``只会把``\n``当成一行结束标志，因此得到的结果中会有``\r``

     同时注意正则匹配的思路一般是将一个目标转化为需要匹配的字符串，即如果目标是\n，即匹配``\\n``，然后转化为正则表达式``\\\\n``（注意普通字符串下``\``是转义字符，正则下也是），不过``Python``如果加``r``（表示原生字符串，上述就是``\\n``了）就不用加``4``个``\\\\``了，两个就可以了

     注意特殊字符``$,(),*,+.,{,[,?,\,^,|``(``|``匹配左边或右边)

  2. **数量控制字符**

     **贪婪型**

     | ?         | 表示0个或1个             |
     | --------- | ------------------------ |
     | *****     | **表示0个或多个**        |
     | **+**     | **表示1个或多个**        |
     | **{n}**   | **表示正好n个**          |
     | **{n,}**  | **表示至少n个**          |
     | **{n,m}** | **表示n到m个，左闭右闭** |

     就是尽可能多的匹配直到不匹配就接着匹配下一个，如果发现下一个不匹配就回溯，比如``jjkjjjk\tlll``，正则表达式为``\w+j``，刚开始时匹配``\w+``匹配到``jjkjjk``结果发现没了就接着匹配``j``结果发现下一个不是``j``，于是就回溯，发现最大匹配为``jjkjjj``，就是想要的结果

     **勉励型**

     在贪婪型后面加上一个``?``即可，与贪婪型相反，勉励型是匹配刚刚好即最少的，就比如上面的例子就是匹配到``jj``

     **占有型**

     在贪婪型后面加一个``+``即可，它和贪婪型很像，是尽可能多的匹配直到不匹配就接着匹配下一个，但是如果下一个不匹配它不会回溯，及上面的例子，它匹配到的就是一个空串

  3. **位置匹配符**

     | ^      | 匹配一行的开始位置                                           |
     | ------ | ------------------------------------------------------------ |
     | **$**  | **匹配一行的结束位置**                                       |
     | **\b** | **匹配单词的边界，这里的单词是指字母，下划线，数字，当然还包括汉字，就是单词字符和非单词字符之间的位置，注意行开头和结尾也叫单词边界** |
     | **\B** | **匹配非单词的边界，就是非单词之间的位置**                   |
     | **\G** | **匹配前一个匹配结束时的位置**                               |

     位置匹配字符都是零宽的，匹配单词边界稍有不同，但向正则表达式添加了很重要的能力。单词边界是单词和空格之间的位置。非单词边界是任何其他位置。下面的表达式匹配单词`` Chapter`` 的开头三个字符，因为这三个字符是出现在单词边界后面：``\bCha``

     **\b** 字符的位置是非常重要的。如果它位于要匹配的字符串的开始，它在单词的开始处查找匹配项。如果它位于字符串的结尾，它在单词的结尾处查找匹配项。例如，下面的表达式匹配单词 ``Chapter`` 中的字符串 ``ter``，因为它是出现在单词边界的前面：``ter\b``

     下面的表达式匹配`` Chapter`` 中的字符串 ``apt``，但不匹配 ``aptitude`` 中的字符串 ``apt``：``\Bapt``字符串`` apt`` 出现在单词 ``Chapter`` 中的非单词边界处，但出现在单词 ``aptitude`` 中的单词边界处。

     对于 **\B** 非单词边界运算符，不可以匹配单词的开头或结尾，如果是下面的表达式，就不匹配 ``Chapter`` 中的 ``Cha``：

     ``\BCha``

  4. **零宽断言匹配**

     | （？=exp)    | exp的前面是匹配的东西         |
     | ------------ | ----------------------------- |
     | **(?<=exp)** | **exp后面是匹配的东西**       |
     | **(?!exp)**  | **即匹配内容的后面不能有exp** |
     | **(?<!exp)** | **即匹配东西的前面不能有exp** |

     

  5. **模式说明符**

     | (!i)     | 大小写忽略模式，只适用于ASCII字符     |
     | -------- | ------------------------------------- |
     | **(?u)** | **开启utf-8编码模式**                 |
     | **(?m)** | **开启多行匹配模式，.不匹配空白字符** |
     | **(?s)** | **单行匹配模式，.匹配任意字符**       |
     | **(?d)** | **单行匹配模式，.不匹配空白字符**     |

     

  6. **``Java``相关组件和``API``**

     ``Pattern``类和``Matcher``类，没有公共构造方法，要创建一个``Pattern``对象就要首先调用其公共静态方法，它返回一个``Pattern``对象，且接收一个正则表达式作为第一个参数，而``Matcher``也没有公共的构造方法，需要调用``Pattern``对象的``matcher``获得一个``Matcher``对象

     创建``Pattern``对象如下：

     ```java
     Pattern r = Pattern.compile(xxxx) // xxxx ---- 正则表达式
     ```

     创建``Matcher``对象

     ```java
     Matcher m = r.matcher(xxxx) // xxxx ---- 字符串
     ```

     ``Pattern``有几个常用方法：

     ```java
     public static Pattern compile(String regex)
         
     public static Pattern compile(String regex, int flags)
     //flags 表示不同匹配模式，最常用的是0,unicode模式
     
     public Matcher matcher(CharSequence input)
     //将整个区域匹配，根据输入内容返回Matcher对象，CharSequence是一个接口，有String,CharBuffer等等实现类
     
     public static boolean matches(String regex, CharSequence input)
     //input完全匹配就可以返回true，反之false
     
     public String[] split(CharSequence input)
     //用正则切割当前字符串
     ```

     ``Matcher``也有几个常用方法如下：

     ```java
     public boolean find()
     //只返回第一次匹配到的结果（最多匹配一次）
         
     public String group()
     //将匹配到内容放在group(0)里面，捕获组内容放在group(n)里面
         
     public boolean matches()
     //和Pattern的matches差不多
         
     public String group(int group)
     //group(0)和直接group()差不多
         
     public int groupCount()
     //上一次分成了几个组
         
     public Matcher reset(CharSequence input)
     //根据输入字符串重新生成一个Matcher对象
         
     public Matcher reset()
     //重置指针，从头开始匹配
         
     public Matcher region(int start, int end)
     //指定头尾指针，重置指针，只匹配给定范围内的字符串，左开右闭，从0开始
         
     public int start(int group)
     //返回头指针（匹配到的子串的第一个字符位置）
         
     public int end()
     //返回上一次匹配后的尾指针
         
     public String replaceFirst(String replacement)
     //不用和find连用替换第一个匹配到的内容
         
     public String replaceAll(String replcement)
     //替换匹配到的全部内容
         
     public int start(int group)
     //返回指定分组在上一次匹配操作后头指针的位置
         
     public int end(int group)
     //返回指定分组在上一次匹配操作之后尾指针的位置
     ```

     

     

  7. **正则分组**

     1. ``()``小括号里面的内容分为一组，一个正则有``n``个小括号，就表示要分成``n+1``组，其中第``0``组就是全部匹配内容
     2. 分组主要分为``4``种，**捕获组**，**非捕获组**，**分组复用**，**分组取名**
        * **捕获组：**就是匹配内容为括号中的内容，``matcher.find()``（匹配一次，但下一次调用从上次匹配完的地方开始匹配，一般和``group``搭配使用）,就将匹配到所有满足括号的内容，然后内容被分成``n``组（括号个数，括号外的匹配但是不捕获），可以调用``groupCount``看捕获个数，注意不包括``0``
        * **分组命名：**在设置分组的时候取名，格式为``(?<name>exp)``，然后用``matcher.group("<name>")``取出匹配组内的内容
        * **非捕获组：**只进行分组但是不捕获，格式为``(?:exp)``你可能会问这有什么用吗？例如我要匹配的内容用到了``|``很可能就要加``()``来限定，于是就会捕获该内容，但我又不想要该内容因此就可以使用非捕获组
        * **分组复用：**这个主要牵扯到``replaceFirst``或者``replaceAll``方法，即替换时可以用``$n``表示第``n``组的内容，相当于不替换这个组的内容

* 如果最后一个有效输入`qsend xxx`之后不是紧跟着`EOF`，而是提行掏出两个空格接下来用显式的\s表示：

  ```
  ...
  qsend xxx
  \s\s
  ```

  这样做，`SCANNER.hasNextLine() == true`，因为`SCANNER.nextLine() = "\s\s"`，然而`SCANNER.next()`期望找到下一个非空白串，可怜的他直到EOF都没有找到，于是悲愤地爆出了“NoSuchElementException”，``next()``遇到有效字符后才可以结束，非有效字符自动去掉，``nextLine()``是遇到``Enter``键，返回``Enter``之前所有字符

* 注意引号在正则表达式中没有多种意思，只要``\"``就好，注意编译器先将你的表达式转换为字符串，再转换为正则表达式，思路可以是先想好正则表达式要不要转义，再想字符串形式要不要转义

* 在``Java``中，私有方法是具有私有访问修饰符的方法，它们被限制为只能在定义类中访问，并且由于不符合覆盖条件而在其子类中不可见。 但是，我们可以在子类中定义一个具有相同名称的方法，并且可以在父类中进行访问。

* ``appendReplacement``方法：``sb``是一个``StringBuffer``，``replaceContext``待替换的字符串，这个方法会把匹配到的内容替换为``replaceContext``，并且把从上次替换的位置到这次替换位置之间的字符串也拿到，然后，加上这次替换后的结果一起追加到``StringBuffer``里（假如这次替换是第一次替换，那就是只追加替换后的字符串啦）。

  ``appendTail``方法：``sb``是一个``StringBuffer``，这个方法是把最后一次匹配到内容之后的字符串追加到``StringBuffer``中。

* 编译和链接多个源文件

  假设您的程序有两个源文件：`file1.cpp`, `file2.cpp`. 您可以在一个命令中编译所有这些：

  ```
  > g ++ -o myprog.exe 文件1.cpp 文件2.cpp 
  ```

  但是，我们通常将每个源文件单独编译成目标文件，并在后期将它们链接在一起。在这种情况下，一个文件中的更改不需要重新编译其他文件。

  ```
  > g++ -c file1.cpp 
  > g++ -c file2.cpp 
  > g++ -o myprog.exe file1.o file2.o
  ```
